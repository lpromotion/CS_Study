### TCP, UDP  
- TCP, UDP - 네트워크 계층들 중 전송계층에서 데이터를 보내기 위해 사용하는 프로토콜
- TCP (Transmission Control Protocol)
  - 전송 제어 프로토콜. 인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
  - 연결형 프로토콜 (패킷을 전송하기 위한 논리적 경로를 배정함)
  - 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제함
  - 높은 신뢰성을 보장
  - 흐름 제어 및 혼잡 제어
  - UDP 보다 속도가 느림
  - TCP는 연속성보다 신뢰성있는 전송이 중요할 때 사용 ex) 파일 전송 

- UDP (User Datagram Protocol)
  - 사용자 데이터그램 프로토콜. 데이터를 데이터그램 단위로 처리하는 프로토콜  
    - 데이터그램 : 독립적인 관계를 지니는 패킷이라는 뜻
  - 비연결형 프로토콜 (연결을 위해 할당되는 논리적인 경로가 없음)  
    -> 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지님
  - 정보를 주고 받을 때 정보를 보내거나 받는다른 신호절차를 거치지 않음
  - 신뢰성이 낮음
  - TCP보다 속도가 빠름
  - 신뢰성보다는 연속성이 중요한 서비스에 사용 ex) 실시간 서비스   

<img src="https://user-images.githubusercontent.com/88132500/236442972-381dae66-4e7f-42e3-9b5a-d9470a72ecae.png" width="50%" height="50%"></img>

- 3-Handshaking
  - 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작되기 전에 한쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 함
  - 양쪽 모두 상대편에 대한 초기 순차 일련번호를 얻을 수 있도록 함
  - 과정  
    <img src="https://user-images.githubusercontent.com/88132500/236444327-a0dbfc6a-2661-4651-a084-117145f565b9.png" width="50%" height="50%"></img>  
    - [step 1] A 클라이언트는 B 서버에 접속을 요청하는 SYN(요청) 패킷을 보냄. 이때 A클라이언트는 SYN 을 보내고 SYN(요청)/ACK(승인) 응답을 기다리는 SYN_SENT 상태, B서버는 Wait for Client 상태  
    - [step 2] B 서버는 SYN 요청을 받고 A 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고 A가 다시 ACK로 응답하기를 기다림. 이때 B 서버는 SYN_RECEIVED 상태가 됨  
    - [step 3] A 클라이언트는 B 서버에게 ACK를 보내고 이후부터는 연결이 이루어지고 데이터가 오가게 됨. 이때의 B 서버 상태가 ESTABLISHED(포트 연결 상태).  
  - *3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면?*
    - 서버는 클라이언트로부터 확인받았다는 ACK를 받지 못하기 때문에 SYN_RECV상태의 세션이 계속 쌓이게 됨. 이러한 세션이 쌓이면 SYN Backlog가 가득 차게 되며, 결국 더이상 SYN 소켓 정보를 쌓을 수 없어 SYN Drop이 발생함. 즉, SYN Backlog가 가득 차 새로운 세션을 생성하지 못하게 됨.
    - 해결방법 -> 세션을 쌓는 공간의 크기를 더 늘리거나, SYN+ACK의 재전송 횟수를 설정하여 설정한 횟수까지 응답이 없으면 소켓 연결을 끊음
- 4-Handshaking  
  - 세션을 종료하기 위해 수행되는 절차  
  - 과정  
    <img src="https://user-images.githubusercontent.com/88132500/236445799-397ceebf-3be7-4147-89d9-b16f35a0bd5f.png" width="50%" height="50%"></img>  
    - [step 1] 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송함. 이때 A 클라이언트는 FIN_WAIT 상태가 됨  
    - [step 2] B 서버는 FIN 플래그를 받고, 확인 메시지 ACK를 보냄. 그리고 자신의 통신이 끝날 때까지 기다리는데 이 상태가 B 서버의 CLOSE_WAIT 상태.  
    - [step 3] 연결을 종료할 준비가 되면, 연결 해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN 플래그를 전송함. 이때 B 서버의 상태는 LAST_ACK.
    - [step 4] 클라이언트는 해지 준비가 되었다는 ACK를 확인했다는 메시지를 보냄. A 클라이언트의 상태가 FIN_WAIT -> TIME_WAIT로 변경됨  
  - *4-way handshaking 과정에서 클라이언트가 마지막에 ACK를 굳이 보내는 이유?*  
    - 서버가 클라이언트에게 FIN을 보낼 때의 의미는 서버가 더 이상 보낼 데이터가 없음을 클라이언트에게 알려주기 위함임. 만약 FIN이 유실된다면 클라이언트는 서버가 아직 보낼 데이터가 있다고 인식하게 되고 계속 대기함. 그렇기 때문에 서버 입장에서는 클라이언트가 FIN을 확실히 받았는지 알아야 함. 그렇게 하기 위해서, 클라이언트는 마지막 ACK를 응답으로 보내야 함.
  
